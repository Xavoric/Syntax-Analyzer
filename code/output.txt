OUTPUT: S->if(A)SS'
MATCH: if
MATCH: (
OUTPUT: A->BA'
OUTPUT: B->CB'
OUTPUT: C->EopE
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->identifier
MATCH: identifier
OUTPUT: F'->#
OUTPUT: E'->#
OUTPUT: op-><
MATCH: <
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->value
MATCH: value
OUTPUT: F'->#
OUTPUT: E'->#
OUTPUT: B'->&&CB'
MATCH: &&
OUTPUT: C->true
MATCH: true
OUTPUT: B'->#
OUTPUT: A'->#
MATCH: )
OUTPUT: S->{S}
MATCH: {
OUTPUT: S->R=E
OUTPUT: R->identifier
MATCH: identifier
MATCH: =
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->identifier
MATCH: identifier
OUTPUT: F'->#
OUTPUT: E'->+FE'
MATCH: +
OUTPUT: F->GF'
OUTPUT: G->value
MATCH: value
OUTPUT: F'->*GF'
MATCH: *
OUTPUT: G->value
MATCH: value
OUTPUT: F'->/GF'
MATCH: /
OUTPUT: G->value
MATCH: value
OUTPUT: F'->#
OUTPUT: E'->#
MATCH: }
OUTPUT: S'->elseS
MATCH: else
OUTPUT: S->{S}
MATCH: {
OUTPUT: S->while(A)S
MATCH: while
MATCH: (
OUTPUT: A->BA'
OUTPUT: B->CB'
OUTPUT: C->EopE
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->identifier
MATCH: identifier
OUTPUT: F'->#
OUTPUT: E'->#
OUTPUT: op->>=
MATCH: >=
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->value
MATCH: value
OUTPUT: F'->#
OUTPUT: E'->#
OUTPUT: B'->#
OUTPUT: A'->||BA'
MATCH: ||
OUTPUT: B->CB'
OUTPUT: C->false
MATCH: false
OUTPUT: B'->#
OUTPUT: A'->#
MATCH: )
OUTPUT: S->{S}
MATCH: {
OUTPUT: S->R=E
OUTPUT: R->identifier
MATCH: identifier
MATCH: =
OUTPUT: E->FE'
OUTPUT: F->GF'
OUTPUT: G->value
MATCH: value
OUTPUT: F'->#
OUTPUT: E'->#
MATCH: }
MATCH: }
ACCEPT
